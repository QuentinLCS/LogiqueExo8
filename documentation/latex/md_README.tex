\hypertarget{md_README_autotoc_md1}{}\doxysection{$<$em$>$\+Jeu en langage C à réaliser au semestre 2 à l\textquotesingle{}\+E\+N\+S\+I\+I\+E.$<$/em$>$}\label{md_README_autotoc_md1}
\href{https://www.ensiie.fr/}{\texttt{ }}

Dillinger is a cloud-\/enabled, mobile-\/ready, offline-\/storage compatible, Angular\+J\+S-\/powered H\+T\+M\+L5 Markdown editor.


\begin{DoxyItemize}
\item Type some Markdown on the left
\item See H\+T\+ML in the right
\item ✨\+Magic ✨
\end{DoxyItemize}\hypertarget{md_README_autotoc_md2}{}\doxysection{Features}\label{md_README_autotoc_md2}

\begin{DoxyItemize}
\item Import a H\+T\+ML file and watch it magically convert to Markdown
\item Drag and drop images (requires your Dropbox account be linked)
\item Import and save files from Git\+Hub, Dropbox, Google Drive and One Drive
\item Drag and drop markdown and H\+T\+ML files into Dillinger
\item Export documents as Markdown, H\+T\+ML and P\+DF
\end{DoxyItemize}

Markdown is a lightweight markup language based on the formatting conventions that people naturally use in email. As \href{http://daringfireball.net>}{\texttt{ John Gruber}} writes on the \href{http://daringfireball.net/projects/markdown/>}{\texttt{ Markdown site}}

\begin{quote}
The overriding design goal for Markdown\textquotesingle{}s formatting syntax is to make it as readable as possible. The idea is that a Markdown-\/formatted document should be publishable as-\/is, as plain text, without looking like it\textquotesingle{}s been marked up with tags or formatting instructions. \end{quote}


This text you see here is $\ast$actually-\/ written in Markdown! To get a feel for Markdown\textquotesingle{}s syntax, type some text into the left window and watch the results in the right.\hypertarget{md_README_autotoc_md3}{}\doxysection{Développeurs}\label{md_README_autotoc_md3}
Ce projet a été réalisé par 4 étudiants de prémière année en formation ingénieur informatique par apprentissage. Une répartition égale des tâches à dû être effectuée.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ N\+OM }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ P\+R\+E\+N\+OM }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ T\+A\+C\+H\+ES  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ N\+OM }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ P\+R\+E\+N\+OM }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ T\+A\+C\+H\+ES  }\\\cline{1-3}
\endhead
D\+R\+A\+B\+C\+Z\+UK &Barthélémy &A.\+3 /  \\\cline{1-3}
L\+A\+G\+U\+I\+L\+L\+ON &Céline &A.\+4 /  \\\cline{1-3}
L\+E\+C\+H\+A\+S\+L\+ES &Quentin &A.\+1 /  \\\cline{1-3}
R\+O\+C\+H\+E\+T\+TE &Irvinn &A.\+2 /  \\\cline{1-3}
\end{longtabu}


\begin{quote}
{\itshape {\bfseries{cf. Voir le Gantt du projet réalisé sous {\ttfamily Gantt\+Project -\/ Free version}}}} \end{quote}
\hypertarget{md_README_autotoc_md4}{}\doxysection{Documentation}\label{md_README_autotoc_md4}
Phrase introductive ...\hypertarget{md_README_autotoc_md5}{}\doxysubsection{Installation}\label{md_README_autotoc_md5}
Dillinger requires \href{https://nodejs.org/}{\texttt{ Node.\+js}} v10+ to run.

Install the dependencies and dev\+Dependencies and start the server.


\begin{DoxyCode}{0}
\DoxyCodeLine{cd dillinger}
\DoxyCodeLine{npm i}
\DoxyCodeLine{node app}
\end{DoxyCode}


For production environments...


\begin{DoxyCode}{0}
\DoxyCodeLine{npm install -\/-\/production}
\DoxyCodeLine{NODE\_ENV=production node app}
\end{DoxyCode}
\hypertarget{md_README_autotoc_md6}{}\doxysection{Lot A}\label{md_README_autotoc_md6}
Le premier lot consiste à réfléchir à la mise en place du projet et à préparer les interfaces de vos modules (fichiers .h). Les interfaces ne contiennent que la définition de types (concrets ou abstraits), les signatures des fonctions utiles et des commentaires indiquant leur fonction (et non leur implantation interne). Elle ne contiennent pas de code à proprement parler. Pour les produire, il vous faut donc réfléchir, non pas à comment vous aller les implanter, mais ce que vous voulez que les fonctions fassent. À l’aide de ces signatures, vous pouvez programmer votre fichier 5 principal \mbox{\hyperlink{main_8c}{main.\+c}} en le précompiler en fichier main.\+o. Ce fichier \mbox{\hyperlink{main_8c}{main.\+c}} doit contenir le code du logiciel permettant à un joueur de lancer une partie et de la jouer jusqu’à son terme selon le cahier des charges de la section précédente. Vous ne serez pas en mesure de générer un exécutable à partir de \mbox{\hyperlink{main_8c}{main.\+c}}, puisque les fonctions décrites dans les interfaces ne sont pas encore implantées. Mais ça ne vous empêche pas de les utiliser dans le fichier \mbox{\hyperlink{main_8c}{main.\+c}} puisque vous savez ce que ces fonctions sont sensées prendre en entrée et produire en sortie. Votre fichier devra compiler avec la commande gcc -\/Wall -\/Wextra -\/std=c99 -\/c \mbox{\hyperlink{main_8c}{main.\+c}}. Si vos interfaces et votre fichier \mbox{\hyperlink{main_8c}{main.\+c}} sont corrects, vous n’aurez plus qu’à implanter les fonctions des interfaces pour avoir un programme fonctionnel. Ces tâches sont prévues pour le lot B et le lot C. Le lot B constituera une implantation des fonctions de sorte à jouer en console. Le lot C constituera une évolution du projet (interface graphique, augmentation du nombre de fonctionnalités, . . .). Attribuez chacune des tâches suivantes, à une (et une seule) personne du groupe. N’hésitez pas à découper chaque tâche en sous-\/tâches.\hypertarget{md_README_autotoc_md7}{}\doxysubsection{Tâche A.\+1 – Mise en place du projet et main.\+c}\label{md_README_autotoc_md7}
Votre rôle est central pour le Lot A. Lisez les tâches de tous les membres du groupe avant de commencer. Mettez en place le dépôt git et invitez votre encadrant sur votre dépôt en tant que rapporter ainsi que tous les membres du groupe en tant que developper. Ce git contiendra votre code. Créez une première branche lot\+\_\+a. Le dernier commit de cette branche contiendra le code du Lot A une fois celui-\/ci terminé. Créer un projet avec Gantt\+Project et poussez le sur votre dépot git, dans la branche lot\+\_\+a. Remplissez ce fichier avec les différentes tâches du Lot A. Mettez des durées arbitraires sur vos tâches. Ajoutez chaque membre du groupe comme ressource. Affectez les ressources aux tâches après décision de qui effectue quelle tâche. (Rappel \+: c’est nécessaire pour qu’une tâche soit attribuée à un membre du groupe). Enfin, indiquez les contraintes de précédences sur les tâches (quelle tâche doit être finie pour pouvoir commencer une nouvelle tâche). Vous pouvez couper les tâches en sous-\/taches sur vous voulez. Codez le fichier \mbox{\hyperlink{main_8c}{main.\+c}}. Ce fichier devra utiliser toutes les fonctions et uniquement les fonctions qui auront été ajoutées dans les interfaces remplies par les autres membres du groupe. Remarque \+: ce fichier restera normalement inchangé tout le long du Lot B. Une fois ce dernier terminé, \mbox{\hyperlink{main_8c}{main.\+c}} pourra être compilé en un exécutable qui fera tourner le projet. Vérifiez, une fois toutes les interfaces rédigées, que votre fichier \mbox{\hyperlink{main_8c}{main.\+c}} compile sous forme de fichier objet main.\+o. Faites valider le Lot A par votre encadrant une fois toutes les tâches terminées. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche A.\+1 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md8}{}\doxysubsection{Tâche A.\+2 – carte.\+h}\label{md_README_autotoc_md8}
L’interface \mbox{\hyperlink{carte_8h_source}{carte.\+h}} est en charge de la carte de jeu. Elle doit permettre d’accéder à l’ensemble des machines, sources, ressources, déchets, personnels et porte présents sur la carte. Elle doit également permettre de modifier cette carte en fonction des décisions prises par le joueur. C’est aussi cette interface qui gère les différents tours de jeu et les E et DD disponibles du joueur. Ajoutez chacun des types et des fonctions suivants, avec les paramètres qui vous semblent adéquats à vous et au responsable de la tâche A.\+1 pour coder le fichier \mbox{\hyperlink{main_8c}{main.\+c}}. Documentez ensuite ces fonctions et ces types. — un type carte (possiblement abstrait) — une fonction pour créer une carte — une fonction pour libérer la mémoire allouée à une carte — une fonction pour recruter un F\+I\+SE — une fonction pour recruter un F\+I\+SA — une fonction pour changer le type de ressource créée par les F\+I\+SA — une fonction pour terminer le tour. D’autres fonctions sont prévues dans \mbox{\hyperlink{carte_8h_source}{carte.\+h}} dans la tâche A.\+3. Attention \+: aucune de ces fonctions n’échange d’informations avec le joueur humain (pas de printf, pas de scanf). C’est le rôle de \mbox{\hyperlink{interface_8h}{interface.\+h}}. On rappelle qu’un fichier .h ne contient pas de code, juste des signatures de fonctions. 6 Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche A.\+2 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md9}{}\doxysubsection{Tâche A.\+3 – machine.\+h, personnel.\+h et fin carte.\+h}\label{md_README_autotoc_md9}
L’interface \mbox{\hyperlink{machine_8h_source}{machine.\+h}} est en charge de gérer les informations des machines du jeu, indépendamment de leur existence dans le jeu. De même l’interface \mbox{\hyperlink{personnel_8h_source}{personnel.\+h}} est en charge de gérer les informations du personnel du jeu, indépendamment de leur existence dans le jeu. C’est dans ces interfaces qu’on retrouvera par exemple les informations de coût des machines ou du personnel. Ajoutez à \mbox{\hyperlink{machine_8h_source}{machine.\+h}} un type machine (possiblement abstrait). Ajoutez à \mbox{\hyperlink{personnel_8h_source}{personnel.\+h}} un type personnel (possiblement abstrait). Ajoutez à \mbox{\hyperlink{carte_8h_source}{carte.\+h}} les fonction suivantes. Documentez ensuite ces fonctions et ces types. — une fonction pour ajouter une nouvelle machine, si le budget le permet — une fonction pour améliorer un machine, si le budget le permet — une fonction pour détruire un machine, si le budget le permet — une fonction pour acheter un membre du personnel, si le budget le permet Attention \+: aucune de ces fonctions n’échange d’informations avec le joueur humain (pas de printf, pas de scanf). C’est le rôle de \mbox{\hyperlink{interface_8h}{interface.\+h}}. On rappelle qu’un fichier .h ne contient pas de code, juste des signatures de fonctions. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche A.\+3 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md10}{}\doxysubsection{Tâche A.\+4 – interface.\+h}\label{md_README_autotoc_md10}
L’interface \mbox{\hyperlink{interface_8h}{interface.\+h}} est en charge de tous les échanges entre le joueur humain et le jeu \+: affichage et prise de décision du joueur. — une fonction pour demander la taille d’une nouvelle carte en début de jeu — une fonction pour afficher la carte — une fonction pour demander une action au joueur (quitter le jeu, passer au tour suivant, ajouter une machine, . . .) — une fonction pour demander au joueur des informations nécessaires pour ajouter une nouvelle machine à la carte — une fonction pour demander au joueur des informations nécessaires pour sélectionner une machine de la carte (pour l’améliorer ou la détruire) — une fonction pour demander au joueur des informations nécessaires pour sélectionner un membre du personnel à acheter Aucune de ces fonctions ne modifie la carte de jeu. C’est le rôle de \mbox{\hyperlink{carte_8h_source}{carte.\+h}}. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche A.\+4 (en plus d’un message décrivant le commit). \hypertarget{md_README_autotoc_md11}{}\doxysection{Lot B}\label{md_README_autotoc_md11}
Le but du Lot B est de permettre de compiler pleinement le fichier \mbox{\hyperlink{main_8c}{main.\+c}} en un exécutable fonctionnel. Il faudra ici implanter toutes les fonctions des interfaces créées dans le Lot A. Vous ne devez plus déplacer la branche lot\+\_\+a. Elle restera définitivement pointée sur la fin de votre travail précédent même si vous remettez en question ce travail ultérieurement. Attribuez chacune des tâches suivantes, à une personne (et une seule) du groupe. N’hésitez pas à découper chaque tâche en sous-\/taches. Notez que certaines tâches sont plus faciles et courtes que d’autres. 7\hypertarget{md_README_autotoc_md12}{}\doxysubsection{Tâche B.\+1 – Lier tous les fichiers}\label{md_README_autotoc_md12}
Dans le dépot git, créez une deuxième branche lot\+\_\+b. Le dernier commit de cette branche contiendra le code du Lot B une fois celui-\/ci terminé. Vous pouvez, vous ou les autres membres du groupe, si vous le souhaitez, créer d’autres branches temporaires le temps de la conception du Lot B. Créer un fichier makefile et quatre dossiers src, obj, bin et headers pour ranger vos fichiers. Remplissez le makefile pour qu’il permette, à terme, de compiler chacun des fichiers sources en fichier objet (.o) et le fichier main.\+o en un exécutable. Remplissez le fichier Gantt\+Project avec les différentes tâches du Lot B. Mettez des durées arbitraires sur vos tâches. Affectez les ressources aux tâches après décision de qui effectue quelle tâche. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+1 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md13}{}\doxysubsection{Tâche B.\+2 – Tester votre code}\label{md_README_autotoc_md13}
Créez sur le dépot git une branche lot\+\_\+b\+\_\+test dans laquelle vous effectuerez vos tests sans affecter le code du lot\+\_\+b. Créez un fichier test.\+c qui vous permettra de tester. N’hésitez par à modifier le code des autres et à commiter, il n’y a pas de risque, vous êtes sur une autre branche. Vous pouvez utiliser C\+Unit si vous le souhaitez. Effectuez les tests de l’exécutable. Remontez les bugs aux membres du groupe pour déterminer qui doit corriger ce bug. Vous pouvez par exemple commiter sur lot\+\_\+b\+\_\+test un code qui démontre le bug. Pensez à garder une trace écrite de vos tests, en particulier si le bug est visuel, s’il n’affecte pas le fonctionnement du jeu, s’il n’est pas codable, vous pouvez simplement décrire le bug dans un fichier texte que vous commiterez. Corrigez ce bug sur la branche lot\+\_\+b. Puis fusionnez les deux branches et recommencez. Vos tests doivent inclure toutes les règles du jeu. Par exemple \+: — démarrage sans problème du jeu — vérification des fuites mémoires avec valgrind — placement original des sources et de la porte — recrutement de F\+I\+SE ou de F\+I\+SA — changement de type de ressource créée par les F\+I\+SA — achat d’une machine — amélioration d’une machine — destruction d’une machine — collecte de ressources ou de déchets — déplacement de ressources ou de déchets avec un tapis ou une croix — disparition des ressources/déchets (quand ils tombent par terre ou son envoyés sur une sortie d’une machine) — diminution des DD avec les déchets — stockage en déchetterie — recyclage des déchets — achat du personnel — achat du même personnel plusieurs fois — tout autre idée de votre part . . . Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+2 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md14}{}\doxysubsection{Tâche B.\+3 – Structures de données – structures.\+h}\label{md_README_autotoc_md14}
Attention, on parle bien ici de structures de donnée (tableau, file, pile, ensemble, dictionnaire, . . .), pas de structure au sens struct en C. Créez un nouveau fichier structure.\+h qui gérera toutes vos structures de données. Ces structures gèreront le contenu de la carte, la liste des machines ou des personnels achetés, . . . . Ces structures seront utilisées pour implanter les types carte, machine et personnel. 8 Il peut s’agit de simples tableaux ou de structures plus évoluées. Ajoutez des types et des fonctions permettant de gérer ces structures (ajout, suppression, lecture du i-\/eme élément, . . .). Documentez ensuite ces fonctions et implantez les dans un fichier structure.\+c. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+3 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md15}{}\doxysubsection{Tâche B.\+4 – Constantes et variables globales}\label{md_README_autotoc_md15}
Les règles du jeu disposent de beaucoup de constantes. Placez dans les fichier \mbox{\hyperlink{carte_8h_source}{carte.\+h}}, \mbox{\hyperlink{machine_8h_source}{machine.\+h}} et \mbox{\hyperlink{personnel_8h_source}{personnel.\+h}} des constantes ou des variables globales contenant les différents paramètres du jeu. Vous pouvez aussi créer un fichier annexe contenant ces informations. Par exemple le nombre de F\+I\+SE au début du jeu, le nom des différents membres du personnel, de combien diminue le coût de construction des machines si Kevin Goilard est acheté, ... Ces constantes vous donneront plus facilement accès à ces informations. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+4 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md16}{}\doxysubsection{Tâche B.\+5 – Getters de machine.\+h, machine.\+c, personnel.\+h et personnel.\+c}\label{md_README_autotoc_md16}
Implantez le type machine dans le fichier machine.\+c et le type personnel dans le fichier personnel.\+c. Ajoutez à \mbox{\hyperlink{machine_8h_source}{machine.\+h}} des fonctions utiles pour récupérer des informations sur les machines \+: par exemple récupérer les coûts ou l’orientation de la machine. Implantez ces fonctions dans machine.\+c. Ajoutez à \mbox{\hyperlink{personnel_8h_source}{personnel.\+h}} des fonctions utiles pour récupérer des informations sur le personnel \+: par exemple récupérer les coûts de la personne. Implantez ces fonctions dans personnel.\+c. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+5 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md17}{}\doxysubsection{Tâche B.\+6 – Getters de carte.\+h et carte.\+c}\label{md_README_autotoc_md17}
Implantez le type carte dans le fichier carte.\+c. Ajoutez à \mbox{\hyperlink{carte_8h_source}{carte.\+h}} des fonctions utiles pour récupérer des informations sur la carte \+: récupérer les ressources et déchets de chaque case, le nombre de F\+I\+SE ou F\+I\+SA recrutés, la quantité d’E ou de DD, . . . En d’autres termes, toutes les fonctions qui vous semblent adéquates à vous et à votre référent pour coder le fichier carte.\+c et le fichier interface.\+c des tâches B.\+6 et B.\+7. Documentez ensuite ces fonctions et implantez les dans carte.\+c. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+6 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md18}{}\doxysubsection{Tâche B.\+7 – carte.\+c}\label{md_README_autotoc_md18}
Implantez toutes les fonctions restantes du fichier \mbox{\hyperlink{carte_8h_source}{carte.\+h}} dans le fichier carte.\+c. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+7 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md19}{}\doxysubsection{Tâche B.\+8 – interface.\+c}\label{md_README_autotoc_md19}
Implantez toutes les fonctions du fichier \mbox{\hyperlink{interface_8h}{interface.\+h}} dans le fichier interface.\+c. Conseil \+: contentez vous dans un premier temps d’un affichage simple. Quand il fonctionnera, vous pourrez le faire évoluer vers une esthétique de meilleure qualité. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail. Vos commits doivent avoir l’indication Tâche B.\+8 (en plus d’un message décrivant le commit).\hypertarget{md_README_autotoc_md20}{}\doxysection{Lot C}\label{md_README_autotoc_md20}
Le Lot C est complètement libre.

Rédigez un petit rapport ou présentez oralement votre projet au chargé de projet, selon ce que vous et lui préférez. Voici quelques idées \+:

— Vous pouvez tenter de mesurer l’impact environnemental de votre code. Par exemple en observant sa consommation mémoire avec top ou valgrind, le temps C\+PU utilisé avec time, ou les lectures écritures sur le disque avec l’outil iotop. Vous pouvez aller à fond et regarder la consommation électrique de la machine pendant l’exécution du jeu, mais il vous faut un wattmètre.

— Vous pouvez utiliser une bibliothèque d’interface graphique pour passer d’un jeu en console à un jeu graphique.

— Vous pouvez changer des règles. Par exemple créez des machines qui fabriquent des objets à partir des ressources, créez d’autres améliorations que le joueur peut acheter en cours de route, rendre le jeu multijoueur . . . Les changements doivent être drastiques. Une modification mineure ne sera pas une contribution très intéressante.

Organisez votre Lot en tâches, répartissez les tâches comme dans les autres lots. Vous devez maintenir le dépot git à jour au fur et à mesure de l’avancement de votre travail.

{\bfseries{Merci pour votre lecture !}} 